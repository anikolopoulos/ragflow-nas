#!/bin/bash
#
# RAGFlow Backup Verification Script
# Verifies backup integrity and generates health reports
#
# Author: Generated by Claude Code
# Version: 1.0
# Date: $(date +%Y-%m-%d)
#

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
BACKUP_ROOT="/share/backups/ragflow"
LOG_FILE="/tmp/ragflow_verify_$(date +%Y%m%d_%H%M%S).log"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging function
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$LOG_FILE"
    
    case $level in
        "ERROR") echo -e "${RED}${message}${NC}" ;;
        "SUCCESS") echo -e "${GREEN}${message}${NC}" ;;
        "WARNING") echo -e "${YELLOW}${message}${NC}" ;;
        "INFO") echo -e "${BLUE}${message}${NC}" ;;
    esac
}

# Usage
usage() {
    cat << EOF
RAGFlow Backup Verification Script

Usage: $0 [OPTIONS]

Options:
    -d, --date DATE         Verify backup from specific date (YYYY-MM-DD)
    -a, --all              Verify all available backups
    -r, --report           Generate detailed report
    -q, --quick            Quick verification only
    -h, --help             Show this help message

Examples:
    $0 --date 2025-07-17   # Verify specific backup
    $0 --all --report      # Verify all backups with detailed report
    $0 --quick             # Quick verification of latest backup

EOF
}

# Get latest backup date
get_latest_backup() {
    find "${BACKUP_ROOT}/daily" -maxdepth 1 -type d -name "20*" | sort | tail -n1 | xargs basename 2>/dev/null || echo ""
}

# Verify MySQL backup
verify_mysql() {
    local backup_dir=$1
    local mysql_backup=$(find "$backup_dir" -name "mysql_*.sql.gz" | head -n1)
    
    if [ -z "$mysql_backup" ]; then
        log "ERROR" "MySQL backup file not found"
        return 1
    fi
    
    # Check if file is readable and not corrupted
    if ! gzip -t "$mysql_backup" 2>/dev/null; then
        log "ERROR" "MySQL backup file is corrupted: $mysql_backup"
        return 1
    fi
    
    # Check file size (should be at least 1MB for a real database)
    local size=$(stat -f%z "$mysql_backup" 2>/dev/null || stat -c%s "$mysql_backup" 2>/dev/null || echo 0)
    if [ "$size" -lt 1048576 ]; then
        log "WARNING" "MySQL backup seems unusually small: $(du -h "$mysql_backup" | cut -f1)"
    fi
    
    # Verify SQL content
    if zcat "$mysql_backup" | head -20 | grep -q "CREATE DATABASE"; then
        log "SUCCESS" "MySQL backup verification passed: $mysql_backup"
        return 0
    else
        log "ERROR" "MySQL backup does not contain expected SQL content"
        return 1
    fi
}

# Verify MinIO backup
verify_minio() {
    local minio_backup="${BACKUP_ROOT}/minio_mirror"
    
    if [ ! -d "$minio_backup" ]; then
        log "ERROR" "MinIO backup directory not found: $minio_backup"
        return 1
    fi
    
    # Check if ragflow bucket exists
    if [ ! -d "${minio_backup}/ragflow" ]; then
        log "WARNING" "MinIO ragflow bucket backup not found"
        return 1
    fi
    
    # Count files and calculate size
    local file_count=$(find "${minio_backup}/ragflow" -type f | wc -l)
    local size=$(du -sh "$minio_backup" | cut -f1)
    
    log "SUCCESS" "MinIO backup verification passed: ${file_count} files, ${size} total"
    return 0
}

# Verify Elasticsearch backup
verify_elasticsearch() {
    local backup_dir=$1
    local es_backup_dir=$(find "$backup_dir" -name "elasticsearch_snapshots" -type d | head -n1)
    
    if [ -z "$es_backup_dir" ]; then
        log "WARNING" "Elasticsearch backup not found (may be intentional)"
        return 0
    fi
    
    # Check for snapshot metadata
    if find "$es_backup_dir" -name "snap-*.dat" | head -1 | read; then
        log "SUCCESS" "Elasticsearch backup verification passed"
        return 0
    else
        log "ERROR" "Elasticsearch backup appears incomplete"
        return 1
    fi
}

# Verify configuration backup
verify_config() {
    local backup_dir=$1
    local config_backup=$(find "$backup_dir" -name "config_*.tar.gz" | head -n1)
    
    if [ -z "$config_backup" ]; then
        log "ERROR" "Configuration backup file not found"
        return 1
    fi
    
    # Check if archive is readable
    if ! tar -tzf "$config_backup" >/dev/null 2>&1; then
        log "ERROR" "Configuration backup file is corrupted: $config_backup"
        return 1
    fi
    
    # Check for essential files
    local essential_files=("docker-compose.yml" ".env.example")
    for file in "${essential_files[@]}"; do
        if ! tar -tzf "$config_backup" | grep -q "$file"; then
            log "WARNING" "Essential file missing from config backup: $file"
        fi
    done
    
    log "SUCCESS" "Configuration backup verification passed: $config_backup"
    return 0
}

# Verify single backup
verify_backup() {
    local date=$1
    local quick_mode=${2:-false}
    local backup_dir=""
    
    # Find backup directory
    if [ -d "${BACKUP_ROOT}/daily/${date}" ]; then
        backup_dir="${BACKUP_ROOT}/daily/${date}"
    elif [ -d "${BACKUP_ROOT}/weekly/${date}" ]; then
        backup_dir="${BACKUP_ROOT}/weekly/${date}"
    elif [ -d "${BACKUP_ROOT}/monthly/${date}" ]; then
        backup_dir="${BACKUP_ROOT}/monthly/${date}"
    else
        log "ERROR" "Backup not found for date: $date"
        return 1
    fi
    
    log "INFO" "Verifying backup: $backup_dir"
    
    local success=0
    local total=0
    
    # Verify MySQL
    total=$((total + 1))
    if verify_mysql "$backup_dir"; then
        success=$((success + 1))
    fi
    
    # Verify MinIO (only check mirror, not date-specific)
    total=$((total + 1))
    if verify_minio; then
        success=$((success + 1))
    fi
    
    # Verify Elasticsearch
    if [ "$quick_mode" = false ]; then
        total=$((total + 1))
        if verify_elasticsearch "$backup_dir"; then
            success=$((success + 1))
        fi
    fi
    
    # Verify Configuration
    total=$((total + 1))
    if verify_config "$backup_dir"; then
        success=$((success + 1))
    fi
    
    # Calculate score
    local score=$((success * 100 / total))
    
    if [ $score -eq 100 ]; then
        log "SUCCESS" "Backup verification PASSED: ${success}/${total} components verified"
    elif [ $score -ge 75 ]; then
        log "WARNING" "Backup verification PARTIAL: ${success}/${total} components verified"
    else
        log "ERROR" "Backup verification FAILED: ${success}/${total} components verified"
    fi
    
    return $((total - success))
}

# Generate detailed report
generate_report() {
    local report_file="${BACKUP_ROOT}/backup_health_report_$(date +%Y%m%d_%H%M%S).txt"
    
    log "INFO" "Generating detailed backup health report..."
    
    cat > "$report_file" << EOF
RAGFlow Backup Health Report
============================
Generated: $(date)
Report by: RAGFlow Backup Verification Script

STORAGE OVERVIEW
================
Backup Root: ${BACKUP_ROOT}
Total Backup Size: $(du -sh "${BACKUP_ROOT}" | cut -f1)

$(df -h "${BACKUP_ROOT}")

BACKUP INVENTORY
================

Daily Backups:
$(find "${BACKUP_ROOT}/daily" -maxdepth 1 -type d -name "20*" | sort | while read dir; do
    if [ -d "$dir" ]; then
        date=$(basename "$dir")
        size=$(du -sh "$dir" | cut -f1)
        echo "  $date - $size"
    fi
done)

Weekly Backups:
$(find "${BACKUP_ROOT}/weekly" -maxdepth 1 -type d -name "20*" | sort | while read dir; do
    if [ -d "$dir" ]; then
        week=$(basename "$dir")
        size=$(du -sh "$dir" | cut -f1)
        echo "  $week - $size"
    fi
done)

Monthly Backups:
$(find "${BACKUP_ROOT}/monthly" -maxdepth 1 -type d -name "20*" | sort | while read dir; do
    if [ -d "$dir" ]; then
        month=$(basename "$dir")
        size=$(du -sh "$dir" | cut -f1)
        echo "  $month - $size"
    fi
done)

COMPONENT STATUS
================

MinIO Mirror:
  Location: ${BACKUP_ROOT}/minio_mirror
  Status: $([ -d "${BACKUP_ROOT}/minio_mirror/ragflow" ] && echo "✓ Present" || echo "✗ Missing")
  Size: $(du -sh "${BACKUP_ROOT}/minio_mirror" 2>/dev/null | cut -f1 || echo "N/A")
  Files: $(find "${BACKUP_ROOT}/minio_mirror" -type f 2>/dev/null | wc -l || echo "0")

RECENT BACKUPS VERIFICATION
===========================

EOF
    
    # Verify recent backups
    find "${BACKUP_ROOT}/daily" -maxdepth 1 -type d -name "20*" | sort | tail -n 7 | while read -r dir; do
        if [ -d "$dir" ]; then
            local date=$(basename "$dir")
            echo "Verifying $date..." >> "$report_file"
            
            # Run verification and capture output
            if verify_backup "$date" true 2>&1 | grep -E "(SUCCESS|ERROR|WARNING)" >> "$report_file"; then
                echo "  Status: VERIFIED" >> "$report_file"
            else
                echo "  Status: FAILED" >> "$report_file"
            fi
            echo "" >> "$report_file"
        fi
    done
    
    cat >> "$report_file" << EOF

RECOMMENDATIONS
===============

EOF
    
    # Add recommendations based on findings
    local daily_count=$(find "${BACKUP_ROOT}/daily" -maxdepth 1 -type d -name "20*" | wc -l)
    if [ "$daily_count" -lt 7 ]; then
        echo "- Consider running backups more frequently (found only $daily_count daily backups)" >> "$report_file"
    fi
    
    local backup_size=$(du -s "${BACKUP_ROOT}" | cut -f1)
    local available_space=$(df "${BACKUP_ROOT}" | awk 'NR==2 {print $4}')
    if [ "$backup_size" -gt $((available_space / 2)) ]; then
        echo "- Monitor disk space: backups using significant storage" >> "$report_file"
    fi
    
    if [ ! -f "${BACKUP_ROOT}/scripts/backup.sh" ]; then
        echo "- Backup scripts should be stored in ${BACKUP_ROOT}/scripts/" >> "$report_file"
    fi
    
    echo "" >> "$report_file"
    echo "Log File: $LOG_FILE" >> "$report_file"
    
    log "SUCCESS" "Detailed report generated: $report_file"
}

# Check backup schedule compliance
check_schedule_compliance() {
    log "INFO" "Checking backup schedule compliance..."
    
    local today=$(date +%Y-%m-%d)
    local yesterday=$(date -d "yesterday" +%Y-%m-%d 2>/dev/null || date -v-1d +%Y-%m-%d 2>/dev/null)
    
    # Check if today's backup exists
    if [ -d "${BACKUP_ROOT}/daily/${today}" ]; then
        log "SUCCESS" "Today's backup found: $today"
    elif [ -d "${BACKUP_ROOT}/daily/${yesterday}" ]; then
        log "WARNING" "Today's backup missing, but yesterday's backup exists"
    else
        log "ERROR" "Recent backups missing - backup schedule may be broken"
    fi
    
    # Check weekly backup compliance (Sundays)
    local last_sunday=$(date -d "last sunday" +%Y-W%U 2>/dev/null || date -v-sunday +%Y-W%U 2>/dev/null)
    if find "${BACKUP_ROOT}/weekly" -name "*${last_sunday}*" | head -1 | read; then
        log "SUCCESS" "Weekly backup compliance: OK"
    else
        log "WARNING" "Weekly backup missing for $last_sunday"
    fi
    
    # Check monthly backup compliance (1st of month)
    local this_month=$(date +%Y-%m)
    if find "${BACKUP_ROOT}/monthly" -name "*${this_month}*" | head -1 | read; then
        log "SUCCESS" "Monthly backup compliance: OK"
    else
        log "WARNING" "Monthly backup missing for $this_month"
    fi
}

# Main function
main() {
    local date=""
    local verify_all=false
    local generate_detailed_report=false
    local quick_mode=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--date)
                date="$2"
                shift 2
                ;;
            -a|--all)
                verify_all=true
                shift
                ;;
            -r|--report)
                generate_detailed_report=true
                shift
                ;;
            -q|--quick)
                quick_mode=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    log "INFO" "=== RAGFlow Backup Verification Started ==="
    
    # Check if backup root exists
    if [ ! -d "$BACKUP_ROOT" ]; then
        error_exit "Backup root directory not found: $BACKUP_ROOT"
    fi
    
    check_schedule_compliance
    
    if [ "$verify_all" = true ]; then
        log "INFO" "Verifying all available backups..."
        
        local total_backups=0
        local failed_backups=0
        
        # Verify daily backups
        find "${BACKUP_ROOT}/daily" -maxdepth 1 -type d -name "20*" | sort | while read -r dir; do
            if [ -d "$dir" ]; then
                local backup_date=$(basename "$dir")
                total_backups=$((total_backups + 1))
                
                if ! verify_backup "$backup_date" "$quick_mode"; then
                    failed_backups=$((failed_backups + 1))
                fi
            fi
        done
        
        if [ $failed_backups -eq 0 ]; then
            log "SUCCESS" "All backups verified successfully"
        else
            log "WARNING" "$failed_backups out of $total_backups backups failed verification"
        fi
        
    elif [ -n "$date" ]; then
        verify_backup "$date" "$quick_mode"
    else
        # Verify latest backup
        local latest_date=$(get_latest_backup)
        if [ -n "$latest_date" ]; then
            verify_backup "$latest_date" "$quick_mode"
        else
            log "ERROR" "No backups found"
            exit 1
        fi
    fi
    
    if [ "$generate_detailed_report" = true ]; then
        generate_report
    fi
    
    log "SUCCESS" "=== RAGFlow Backup Verification Completed ==="
    log "INFO" "Log file: $LOG_FILE"
}

# Check if script is being sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi