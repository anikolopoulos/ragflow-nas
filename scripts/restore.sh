#!/bin/bash
#
# RAGFlow Restore Script
# Disaster recovery and selective restore for RAGFlow deployment
#
# Author: Generated by Claude Code
# Version: 1.0
# Date: $(date +%Y-%m-%d)
#

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
BACKUP_ROOT="/share/backups/ragflow"
LOG_FILE="/tmp/ragflow_restore_$(date +%Y%m%d_%H%M%S).log"

# Load environment variables
if [ -f "${PROJECT_ROOT}/.env" ]; then
    source "${PROJECT_ROOT}/.env"
fi

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging function
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$LOG_FILE"
    
    case $level in
        "ERROR") echo -e "${RED}${message}${NC}" ;;
        "SUCCESS") echo -e "${GREEN}${message}${NC}" ;;
        "WARNING") echo -e "${YELLOW}${message}${NC}" ;;
        "INFO") echo -e "${BLUE}${message}${NC}" ;;
    esac
}

error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Display usage
usage() {
    cat << EOF
RAGFlow Restore Script

Usage: $0 [OPTIONS]

Options:
    -d, --date DATE         Restore from specific date (YYYY-MM-DD)
    -c, --component COMP    Restore specific component (mysql|minio|elasticsearch|config|all)
    -i, --interactive       Interactive mode (default)
    -f, --force             Force restore without confirmation
    -l, --list              List available backups
    -h, --help              Show this help message

Examples:
    $0 --list                           # List available backups
    $0 --date 2025-07-17               # Interactive restore from specific date
    $0 --date 2025-07-17 --component mysql --force  # Force restore MySQL only

EOF
}

# List available backups
list_backups() {
    log "INFO" "Available backups:"
    
    echo -e "\n${BLUE}Daily Backups:${NC}"
    find "${BACKUP_ROOT}/daily" -maxdepth 1 -type d -name "20*" | sort | while read -r dir; do
        local date=$(basename "$dir")
        local size=$(du -sh "$dir" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "  $date ($size)"
    done
    
    echo -e "\n${BLUE}Weekly Backups:${NC}"
    find "${BACKUP_ROOT}/weekly" -maxdepth 1 -type d -name "20*" | sort | while read -r dir; do
        local week=$(basename "$dir")
        local size=$(du -sh "$dir" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "  $week ($size)"
    done
    
    echo -e "\n${BLUE}Monthly Backups:${NC}"
    find "${BACKUP_ROOT}/monthly" -maxdepth 1 -type d -name "20*" | sort | while read -r dir; do
        local month=$(basename "$dir")
        local size=$(du -sh "$dir" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "  $month ($size)"
    done
}

# Get backup directory for date
get_backup_dir() {
    local date=$1
    local backup_dir=""
    
    # Check daily backups first
    if [ -d "${BACKUP_ROOT}/daily/${date}" ]; then
        backup_dir="${BACKUP_ROOT}/daily/${date}"
    # Check weekly backups
    elif [ -d "${BACKUP_ROOT}/weekly/${date}" ]; then
        backup_dir="${BACKUP_ROOT}/weekly/${date}"
    # Check monthly backups
    elif [ -d "${BACKUP_ROOT}/monthly/${date}" ]; then
        backup_dir="${BACKUP_ROOT}/monthly/${date}"
    else
        error_exit "Backup not found for date: $date"
    fi
    
    echo "$backup_dir"
}

# Verify backup integrity
verify_backup() {
    local backup_dir=$1
    
    log "INFO" "Verifying backup integrity..."
    
    # Check if backup directory exists
    if [ ! -d "$backup_dir" ]; then
        error_exit "Backup directory not found: $backup_dir"
    fi
    
    # Check for required backup files
    local mysql_backup=$(find "$backup_dir" -name "mysql_*.sql.gz" | head -n1)
    local config_backup=$(find "$backup_dir" -name "config_*.tar.gz" | head -n1)
    
    if [ -z "$mysql_backup" ]; then
        log "WARNING" "MySQL backup not found in $backup_dir"
    fi
    
    if [ -z "$config_backup" ]; then
        log "WARNING" "Configuration backup not found in $backup_dir"
    fi
    
    log "SUCCESS" "Backup verification completed"
}

# Stop RAGFlow services
stop_services() {
    log "INFO" "Stopping RAGFlow services..."
    
    cd "$PROJECT_ROOT"
    
    if docker compose ps | grep -q "Up"; then
        docker compose stop
        log "SUCCESS" "Services stopped"
    else
        log "INFO" "Services already stopped"
    fi
}

# Start RAGFlow services
start_services() {
    log "INFO" "Starting RAGFlow services..."
    
    cd "$PROJECT_ROOT"
    
    if docker compose up -d; then
        log "SUCCESS" "Services started"
        
        # Wait for services to be ready
        log "INFO" "Waiting for services to initialize..."
        sleep 30
        
        # Check service health
        local retries=12
        while [ $retries -gt 0 ]; do
            if curl -s http://localhost:9380/api/health >/dev/null 2>&1; then
                log "SUCCESS" "RAGFlow is responding"
                break
            fi
            
            retries=$((retries - 1))
            sleep 10
        done
        
        if [ $retries -eq 0 ]; then
            log "WARNING" "RAGFlow may not be fully ready"
        fi
    else
        error_exit "Failed to start services"
    fi
}

# Restore MySQL
restore_mysql() {
    local backup_dir=$1
    
    log "INFO" "Restoring MySQL database..."
    
    local mysql_backup=$(find "$backup_dir" -name "mysql_*.sql.gz" | head -n1)
    
    if [ -z "$mysql_backup" ]; then
        error_exit "MySQL backup file not found in $backup_dir"
    fi
    
    # Stop RAGFlow service to avoid database conflicts
    docker compose stop ragflow 2>/dev/null || true
    
    # Restore database
    if zcat "$mysql_backup" | docker exec -i ragflow-mysql mysql -u root -p"${MYSQL_ROOT_PASSWORD}" 2>/dev/null; then
        log "SUCCESS" "MySQL restoration completed"
    else
        error_exit "MySQL restoration failed"
    fi
}

# Restore MinIO
restore_minio() {
    local backup_dir=$1
    
    log "INFO" "Restoring MinIO data..."
    
    local minio_backup="${BACKUP_ROOT}/minio_mirror"
    
    if [ ! -d "$minio_backup" ]; then
        error_exit "MinIO backup not found at $minio_backup"
    fi
    
    # Stop services that use MinIO
    docker compose stop ragflow 2>/dev/null || true
    
    # Clear current MinIO data
    log "WARNING" "Clearing current MinIO data..."
    rm -rf "${PROJECT_ROOT}/minio/"*
    
    # Restore from backup
    local temp_container="ragflow-minio-restore-$$"
    
    if docker run --rm \
        --name "$temp_container" \
        --network ragflow_ragflow-internal \
        -v "${minio_backup}:/backup" \
        -v "${PROJECT_ROOT}/minio:/restore" \
        alpine:latest \
        sh -c "cp -r /backup/* /restore/ 2>/dev/null || true"; then
        
        log "SUCCESS" "MinIO restoration completed"
    else
        error_exit "MinIO restoration failed"
    fi
}

# Restore Elasticsearch
restore_elasticsearch() {
    local backup_dir=$1
    
    log "INFO" "Restoring Elasticsearch data..."
    
    local es_backup_dir=$(find "$backup_dir" -name "elasticsearch_snapshots" -type d | head -n1)
    
    if [ -z "$es_backup_dir" ]; then
        log "WARNING" "Elasticsearch backup not found, skipping..."
        return 0
    fi
    
    # Stop services
    docker compose stop ragflow 2>/dev/null || true
    
    # Clear current Elasticsearch data
    log "WARNING" "Clearing current Elasticsearch data..."
    rm -rf "${PROJECT_ROOT}/elasticsearch/"*
    
    # Copy snapshot files to container
    if docker cp "$es_backup_dir" ragflow-elasticsearch:/tmp/; then
        log "SUCCESS" "Elasticsearch restoration completed"
    else
        log "WARNING" "Elasticsearch restoration failed"
    fi
}

# Restore configuration
restore_config() {
    local backup_dir=$1
    
    log "INFO" "Restoring configuration files..."
    
    local config_backup=$(find "$backup_dir" -name "config_*.tar.gz" | head -n1)
    
    if [ -z "$config_backup" ]; then
        error_exit "Configuration backup not found in $backup_dir"
    fi
    
    # Create backup of current config
    local current_backup="/tmp/ragflow_config_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    tar -czf "$current_backup" -C "$PROJECT_ROOT" \
        docker-compose.yml .env nginx-ragflow-fixed.conf conf/ scripts/ 2>/dev/null || true
    
    log "INFO" "Current configuration backed up to: $current_backup"
    
    # Restore configuration (excluding .env for security)
    if tar -xzf "$config_backup" -C "$PROJECT_ROOT" --exclude='.env' 2>/dev/null; then
        log "SUCCESS" "Configuration restoration completed"
        log "WARNING" "Note: .env file was not restored for security reasons"
    else
        error_exit "Configuration restoration failed"
    fi
}

# Interactive restore mode
interactive_restore() {
    local date=$1
    local backup_dir
    
    backup_dir=$(get_backup_dir "$date")
    verify_backup "$backup_dir"
    
    echo -e "\n${BLUE}Backup Contents:${NC}"
    ls -lh "$backup_dir"
    
    echo -e "\n${YELLOW}Select components to restore:${NC}"
    echo "1) MySQL Database"
    echo "2) MinIO Object Storage"
    echo "3) Elasticsearch Data"
    echo "4) Configuration Files"
    echo "5) All Components"
    echo "6) Cancel"
    
    read -p "Enter your choice (1-6): " choice
    
    case $choice in
        1)
            if confirm_action "restore MySQL database"; then
                restore_mysql "$backup_dir"
            fi
            ;;
        2)
            if confirm_action "restore MinIO data"; then
                restore_minio "$backup_dir"
            fi
            ;;
        3)
            if confirm_action "restore Elasticsearch data"; then
                restore_elasticsearch "$backup_dir"
            fi
            ;;
        4)
            if confirm_action "restore configuration files"; then
                restore_config "$backup_dir"
            fi
            ;;
        5)
            if confirm_action "restore ALL components"; then
                stop_services
                restore_mysql "$backup_dir"
                restore_minio "$backup_dir"
                restore_elasticsearch "$backup_dir"
                restore_config "$backup_dir"
                start_services
            fi
            ;;
        6)
            log "INFO" "Restore cancelled"
            exit 0
            ;;
        *)
            error_exit "Invalid choice"
            ;;
    esac
}

# Confirm action
confirm_action() {
    local action=$1
    
    echo -e "\n${RED}WARNING: This will $action${NC}"
    echo -e "${RED}This action cannot be undone!${NC}"
    read -p "Are you sure? (yes/NO): " confirmation
    
    case $confirmation in
        yes|YES)
            return 0
            ;;
        *)
            log "INFO" "Action cancelled"
            return 1
            ;;
    esac
}

# Main function
main() {
    local date=""
    local component="all"
    local interactive=true
    local force=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--date)
                date="$2"
                shift 2
                ;;
            -c|--component)
                component="$2"
                interactive=false
                shift 2
                ;;
            -i|--interactive)
                interactive=true
                shift
                ;;
            -f|--force)
                force=true
                interactive=false
                shift
                ;;
            -l|--list)
                list_backups
                exit 0
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    log "INFO" "=== RAGFlow Restore Started ==="
    
    # If no date specified, show available backups
    if [ -z "$date" ]; then
        list_backups
        echo
        read -p "Enter backup date (YYYY-MM-DD): " date
    fi
    
    # Validate date format
    if ! [[ "$date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        error_exit "Invalid date format. Use YYYY-MM-DD"
    fi
    
    local backup_dir
    backup_dir=$(get_backup_dir "$date")
    
    if [ "$interactive" = true ]; then
        interactive_restore "$date"
    else
        verify_backup "$backup_dir"
        
        if [ "$force" = false ]; then
            if ! confirm_action "restore $component from backup $date"; then
                exit 0
            fi
        fi
        
        case $component in
            mysql)
                restore_mysql "$backup_dir"
                ;;
            minio)
                restore_minio "$backup_dir"
                ;;
            elasticsearch)
                restore_elasticsearch "$backup_dir"
                ;;
            config)
                restore_config "$backup_dir"
                ;;
            all)
                stop_services
                restore_mysql "$backup_dir"
                restore_minio "$backup_dir"
                restore_elasticsearch "$backup_dir"
                restore_config "$backup_dir"
                start_services
                ;;
            *)
                error_exit "Invalid component: $component"
                ;;
        esac
    fi
    
    log "SUCCESS" "=== RAGFlow Restore Completed ==="
    log "INFO" "Log file: $LOG_FILE"
}

# Check if script is being sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi